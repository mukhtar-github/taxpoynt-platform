"""
FastAPI router for HubSpot CRM integration.

This module defines the API endpoints for HubSpot CRM integration.
"""

import json
import logging
from typing import Dict, Any, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Path, Body, Request, status

from app.dependencies.auth import get_current_user
from app.integrations.base.errors import IntegrationError, error_to_dict
from app.integrations.crm.hubspot.connector import get_hubspot_connector, HubSpotConnector
from app.integrations.crm.hubspot.models import (
    HubSpotConnectionConfig,
    HubSpotDeal,
    HubSpotDealInvoice,
    ConnectionTestResult,
    HubSpotWebhookPayload,
)
from app.integrations.crm.hubspot.webhooks import (
    HubSpotWebhookProcessor,
    verify_hubspot_webhook,
    create_webhook_processor
)
from app.tasks.hubspot_tasks import process_hubspot_deal, sync_hubspot_deals

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/hubspot",
    tags=["hubspot"],
    responses={
        401: {"description": "Authentication required"},
        403: {"description": "Insufficient permissions"},
        404: {"description": "Resource not found"},
        500: {"description": "Internal server error"},
    },
)


@router.post(
    "/connect",
    response_model=Dict[str, Any],
    status_code=status.HTTP_201_CREATED,
    summary="Connect to HubSpot CRM",
    description="Create a new connection to HubSpot CRM with OAuth2 credentials",
)
async def connect_hubspot(
    connection_config: HubSpotConnectionConfig,
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Connect to HubSpot CRM.
    
    Args:
        connection_config: HubSpot connection configuration
        current_user: Current authenticated user
        
    Returns:
        Dict with connection details
        
    Raises:
        HTTPException: If connection fails
    """
    try:
        # Check user permissions
        if current_user["id"] != connection_config.user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to create this connection"
            )
            
        # Create connector to test connection
        connector = get_hubspot_connector(connection_config.dict())
        result = await connector.test_connection()
        
        if not result.success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Connection test failed: {result.message}"
            )
            
        # TODO: Store connection in database
        # This would be implemented using a repository or service
        
        return {
            "message": "HubSpot connection established successfully",
            "connection_id": "temp-id-12345",  # This would be generated by the DB
            "connected_at": result.details.get("connected_at")
        }
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_dict
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in connect_hubspot: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post(
    "/test-connection",
    response_model=ConnectionTestResult,
    status_code=status.HTTP_200_OK,
    summary="Test HubSpot connection",
    description="Test connection to HubSpot CRM using provided credentials",
)
async def test_hubspot_connection(
    connection_config: HubSpotConnectionConfig,
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Test connection to HubSpot.
    
    Args:
        connection_config: HubSpot connection configuration
        current_user: Current authenticated user
        
    Returns:
        ConnectionTestResult with test results
        
    Raises:
        HTTPException: If test fails
    """
    try:
        # Check user permissions
        if current_user["id"] != connection_config.user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to test this connection"
            )
            
        # Create connector to test connection
        connector = get_hubspot_connector(connection_config.dict())
        result = await connector.test_connection()
        
        return ConnectionTestResult(
            success=result.success,
            message=result.message,
            details=result.details
        )
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        return ConnectionTestResult(
            success=False,
            message=f"Integration error: {e.message}",
            details=error_dict
        )
    except Exception as e:
        logger.error(f"Unexpected error in test_hubspot_connection: {str(e)}", exc_info=True)
        return ConnectionTestResult(
            success=False,
            message=f"An unexpected error occurred: {str(e)}",
            details={"error_type": e.__class__.__name__}
        )


@router.get(
    "/deals",
    response_model=List[HubSpotDeal],
    status_code=status.HTTP_200_OK,
    summary="Get HubSpot deals",
    description="Retrieve deals from HubSpot CRM",
)
async def get_hubspot_deals(
    connection_id: str = Query(..., description="HubSpot connection ID"),
    limit: int = Query(100, description="Maximum number of deals to return"),
    offset: int = Query(0, description="Offset for pagination"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Get deals from HubSpot.
    
    Args:
        connection_id: HubSpot connection ID
        limit: Maximum number of deals to return
        offset: Offset for pagination
        current_user: Current authenticated user
        
    Returns:
        List of HubSpotDeal objects
        
    Raises:
        HTTPException: If retrieval fails
    """
    try:
        # TODO: Retrieve connection config from database
        # For now, use a mock config
        connection_config = {
            "connection_id": connection_id,
            "organization_id": current_user.get("organization_id"),
            "user_id": current_user.get("id"),
            "auth": {
                "auth_type": "oauth2",
                "token_url": "https://api.hubapi.com/oauth/v1/token",
                "credentials": {
                    "client_id": "mock-client-id",
                    "client_secret": "mock-client-secret",
                    "refresh_token": "mock-refresh-token"
                }
            }
        }
        
        # Create connector
        connector = get_hubspot_connector(connection_config)
        
        # Get deals
        deals_response = await connector.get_deals(limit=limit, offset=offset)
        
        # Transform response to expected model
        deals = []
        for result in deals_response.get("results", []):
            props = result.get("properties", {})
            
            deal = HubSpotDeal(
                id=result.get("id", ""),
                deal_name=props.get("dealname", ""),
                amount=float(props.get("amount", 0.0)) if props.get("amount") else 0.0,
                deal_stage=props.get("dealstage", ""),
                close_date=props.get("closedate"),
                create_date=props.get("createdate"),
                owner_id=props.get("hubspot_owner_id"),
                properties=props
            )
            deals.append(deal)
            
        return deals
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_dict
        )
    except Exception as e:
        logger.error(f"Unexpected error in get_hubspot_deals: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.get(
    "/deals/{deal_id}",
    response_model=HubSpotDeal,
    status_code=status.HTTP_200_OK,
    summary="Get HubSpot deal by ID",
    description="Retrieve a specific deal from HubSpot CRM by its ID",
)
async def get_hubspot_deal_by_id(
    deal_id: str = Path(..., description="HubSpot deal ID"),
    connection_id: str = Query(..., description="HubSpot connection ID"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Get a deal from HubSpot by ID.
    
    Args:
        deal_id: HubSpot deal ID
        connection_id: HubSpot connection ID
        current_user: Current authenticated user
        
    Returns:
        HubSpotDeal object
        
    Raises:
        HTTPException: If retrieval fails
    """
    try:
        # TODO: Retrieve connection config from database
        # For now, use a mock config
        connection_config = {
            "connection_id": connection_id,
            "organization_id": current_user.get("organization_id"),
            "user_id": current_user.get("id"),
            "auth": {
                "auth_type": "oauth2",
                "token_url": "https://api.hubapi.com/oauth/v1/token",
                "credentials": {
                    "client_id": "mock-client-id",
                    "client_secret": "mock-client-secret",
                    "refresh_token": "mock-refresh-token"
                }
            }
        }
        
        # Create connector
        connector = get_hubspot_connector(connection_config)
        
        # Get deal
        result = await connector.get_deal_by_id(deal_id)
        
        # Transform response to expected model
        props = result.get("properties", {})
        
        deal = HubSpotDeal(
            id=result.get("id", ""),
            deal_name=props.get("dealname", ""),
            amount=float(props.get("amount", 0.0)) if props.get("amount") else 0.0,
            deal_stage=props.get("dealstage", ""),
            close_date=props.get("closedate"),
            create_date=props.get("createdate"),
            owner_id=props.get("hubspot_owner_id"),
            properties=props
        )
            
        return deal
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_dict
        )
    except Exception as e:
        logger.error(f"Unexpected error in get_hubspot_deal_by_id: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post(
    "/deals/{deal_id}/create-invoice",
    response_model=HubSpotDealInvoice,
    status_code=status.HTTP_201_CREATED,
    summary="Create invoice from HubSpot deal",
    description="Create an invoice from a HubSpot deal",
)
async def create_invoice_from_deal(
    deal_id: str = Path(..., description="HubSpot deal ID"),
    connection_id: str = Query(..., description="HubSpot connection ID"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Create an invoice from a HubSpot deal.
    
    Args:
        deal_id: HubSpot deal ID
        connection_id: HubSpot connection ID
        current_user: Current authenticated user
        
    Returns:
        HubSpotDealInvoice object
        
    Raises:
        HTTPException: If creation fails
    """
    try:
        # TODO: Retrieve connection config from database
        # For now, use a mock config
        connection_config = {
            "connection_id": connection_id,
            "organization_id": current_user.get("organization_id"),
            "user_id": current_user.get("id"),
            "auth": {
                "auth_type": "oauth2",
                "token_url": "https://api.hubapi.com/oauth/v1/token",
                "credentials": {
                    "client_id": "mock-client-id",
                    "client_secret": "mock-client-secret",
                    "refresh_token": "mock-refresh-token"
                }
            }
        }
        
        # Create connector
        connector = get_hubspot_connector(connection_config)
        
        # Get deal
        deal = await connector.get_deal_by_id(deal_id)
        
        # Transform to invoice
        invoice_data = await connector.transform_deal_to_invoice(deal)
        
        # TODO: Save invoice to database
        # For now, just return the created invoice data
        
        return invoice_data
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_dict
        )
    except Exception as e:
        logger.error(f"Unexpected error in create_invoice_from_deal: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.delete(
    "/connections/{connection_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    response_model=None,  # Proper response_model=None for 204 status code
    summary="Delete HubSpot connection",
    description="Delete an existing HubSpot connection",
)
async def delete_hubspot_connection(
    connection_id: str = Path(..., description="HubSpot connection ID"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Delete a HubSpot connection.
    
    Args:
        connection_id: HubSpot connection ID
        current_user: Current authenticated user
        
    Returns:
        None (204 No Content)
        
    Raises:
        HTTPException: If deletion fails
    """
    try:
        # TODO: Check if connection exists and if user has permission
        
        # TODO: Delete connection from database
        # For now, just return success
        
        # Return None for 204 No Content response
        return None
            
    except IntegrationError as e:
        logger.error(f"HubSpot integration error: {str(e)}")
        error_dict = error_to_dict(e)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=error_dict
        )
    except Exception as e:
        logger.error(f"Unexpected error in delete_hubspot_connection: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post(
    "/webhook/{connection_id}",
    status_code=status.HTTP_200_OK,
    summary="HubSpot webhook handler",
    description="Handle webhook events from HubSpot for deal updates and other changes",
)
async def handle_hubspot_webhook(
    connection_id: str = Path(..., description="HubSpot connection ID"),
    request: Request = None,
):
    """
    Handle webhook events from HubSpot.
    
    Args:
        connection_id: HubSpot connection ID
        request: FastAPI request object containing webhook payload
        
    Returns:
        Dict with processing results
        
    Raises:
        HTTPException: If webhook processing fails
    """
    try:
        # TODO: Retrieve connection config from database using connection_id
        # For now, use a mock config - this would be replaced with actual DB lookup
        connection_config = {
            "connection_id": connection_id,
            "webhook_secret": "your_webhook_secret_here",  # Retrieved from DB
            "auth": {
                "auth_type": "oauth2",
                "token_url": "https://api.hubapi.com/oauth/v1/token",
                "credentials": {
                    "client_id": "mock-client-id",
                    "client_secret": "mock-client-secret",
                    "refresh_token": "mock-refresh-token"
                }
            },
            "settings": {
                "deal_stage_mapping": {
                    "closedwon": "generate_invoice",
                    "closedlost": "cancel_invoice"
                },
                "auto_generate_invoice_on_creation": False
            }
        }
        
        # Get webhook secret from config
        webhook_secret = connection_config.get("webhook_secret", "")
        
        # Verify webhook signature if secret is configured
        if webhook_secret:
            signature_valid = await verify_hubspot_webhook(request, webhook_secret)
            if not signature_valid:
                logger.warning(f"Invalid webhook signature for connection {connection_id}")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid webhook signature"
                )
        
        # Parse webhook payload
        body = await request.body()
        payload_data = json.loads(body.decode('utf-8'))
        
        try:
            webhook_payload = HubSpotWebhookPayload(**payload_data)
        except Exception as e:
            logger.error(f"Invalid webhook payload format: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid webhook payload format: {str(e)}"
            )
        
        # Create webhook processor
        processor = create_webhook_processor(connection_config)
        
        # Process webhook events
        results = await processor.process_webhook_events(webhook_payload.events)
        
        logger.info(f"Processed {results['processed']} webhook events for connection {connection_id}")
        
        return {
            "message": "Webhook processed successfully",
            "connection_id": connection_id,
            "results": results
        }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unexpected error in handle_hubspot_webhook: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post(
    "/connections/{connection_id}/sync-deals",
    status_code=status.HTTP_200_OK,
    summary="Manually sync HubSpot deals",
    description="Manually trigger a sync of deals from HubSpot for a specific connection",
)
async def manually_sync_hubspot_deals(
    connection_id: str = Path(..., description="HubSpot connection ID"),
    days_back: int = Query(30, description="Number of days to look back for deals"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Manually trigger a sync of HubSpot deals.
    
    Args:
        connection_id: HubSpot connection ID
        days_back: Number of days to look back for deals
        current_user: Current authenticated user
        
    Returns:
        Dict with sync results
        
    Raises:
        HTTPException: If sync fails
    """
    try:
        logger.info(f"Manual HubSpot deals sync triggered for connection {connection_id} by user {current_user.get('id')}")
        
        # TODO: Verify user has access to this connection
        
        # Trigger the sync task
        result = await sync_hubspot_deals(connection_id, days_back)
        
        return {
            "message": "HubSpot deals sync completed",
            "connection_id": connection_id,
            "result": result
        }
            
    except Exception as e:
        logger.error(f"Error in manual sync for connection {connection_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )


@router.post(
    "/connections/{connection_id}/process-deal/{deal_id}",
    status_code=status.HTTP_200_OK,
    summary="Manually process HubSpot deal",
    description="Manually trigger processing of a specific HubSpot deal",
)
async def manually_process_hubspot_deal(
    connection_id: str = Path(..., description="HubSpot connection ID"),
    deal_id: str = Path(..., description="HubSpot deal ID"),
    current_user: Dict[str, Any] = Depends(get_current_user),
):
    """
    Manually trigger processing of a specific HubSpot deal.
    
    Args:
        connection_id: HubSpot connection ID
        deal_id: HubSpot deal ID
        current_user: Current authenticated user
        
    Returns:
        Dict with processing results
        
    Raises:
        HTTPException: If processing fails
    """
    try:
        logger.info(f"Manual HubSpot deal processing triggered for deal {deal_id}, connection {connection_id} by user {current_user.get('id')}")
        
        # TODO: Verify user has access to this connection
        
        # Trigger the deal processing task
        result = await process_hubspot_deal(deal_id, connection_id)
        
        return {
            "message": "HubSpot deal processing completed",
            "connection_id": connection_id,
            "deal_id": deal_id,
            "result": result
        }
            
    except Exception as e:
        logger.error(f"Error processing deal {deal_id}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )
