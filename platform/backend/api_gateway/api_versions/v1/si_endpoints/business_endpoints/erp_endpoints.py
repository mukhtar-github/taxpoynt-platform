"""
ERP System Integration Endpoints - API v1
==========================================
System Integrator endpoints for Enterprise Resource Planning system integrations.
Covers: SAP, Oracle, Microsoft Dynamics, NetSuite, Odoo
"""
import logging
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Set, Tuple, Literal
from fastapi import APIRouter, Request, HTTPException, Depends, status, Query
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

from core_platform.authentication.role_manager import PlatformRole
from core_platform.messaging.message_router import ServiceRole, MessageRouter
from api_gateway.role_routing.models import HTTPRoutingContext
from api_gateway.role_routing.role_detector import HTTPRoleDetector
from api_gateway.role_routing.permission_guard import APIPermissionGuard
from ..version_models import V1ResponseModel
from api_gateway.utils.v1_response import build_v1_response
from si_services.onboarding_management.onboarding_service import SIOnboardingService

logger = logging.getLogger(__name__)

# Rich ERP schema definitions surfaced to the frontend data-mapping tool.
# These schemas mirror the canonical payloads returned by our ERP connectors
# (account.move for Odoo, BillingDocument for SAP SD/FI and Invoice for QuickBooks).
# They deliberately include Nigerian compliance context so that the wizard can
# present production-ready mapping guidance instead of the old placeholder data.
ERP_SCHEMA_DEFINITIONS: Dict[str, Dict[str, Any]] = {
    "odoo": {
        "system_id": "odoo",
        "system_name": "Odoo ERP",
        "version": "16.0",
        "description": "Odoo account.move (customer invoice) fields used for FIRS e-invoicing transformation.",
        "categories": [
            {"id": "header", "label": "Invoice Header"},
            {"id": "customer", "label": "Customer"},
            {"id": "amounts", "label": "Amounts & Taxes"},
            {"id": "metadata", "label": "Operational Metadata"},
            {"id": "lines", "label": "Line Items"}
        ],
        "fields": [
            {"id": "name", "name": "Invoice Number", "type": "string", "required": True, "description": "Human friendly invoice number generated by Odoo.", "example": "INV/2024/0012", "category": "header"},
            {"id": "move_type", "name": "Invoice Type", "type": "string", "required": True, "description": "Internal type describing customer invoice, credit note, etc.", "example": "out_invoice", "category": "header"},
            {"id": "invoice_date", "name": "Invoice Date", "type": "date", "required": True, "description": "Date the invoice was issued.", "example": "2024-03-18", "category": "header"},
            {"id": "invoice_date_due", "name": "Due Date", "type": "date", "required": False, "description": "Date payment is due.", "example": "2024-04-17", "category": "header"},
            {"id": "ref", "name": "Customer Reference", "type": "string", "required": False, "description": "Reference provided by the customer (PO number).", "example": "PO-004812", "category": "header"},
            {"id": "partner_id.name", "name": "Customer Name", "type": "string", "required": True, "description": "Customer display name linked to the invoice.", "example": "Dangote Industries Limited", "category": "customer"},
            {"id": "partner_id.vat", "name": "Customer VAT/TIN", "type": "string", "required": False, "description": "Tax Identification Number recorded for the customer.", "example": "12345678-0001", "category": "customer"},
            {"id": "partner_id.email", "name": "Customer Email", "type": "string", "required": False, "description": "Primary email for customer contact.", "example": "billing@dangote.com", "category": "customer"},
            {"id": "partner_id.phone", "name": "Customer Phone", "type": "string", "required": False, "description": "Primary phone number for the customer.", "example": "+234-1-880-1234", "category": "customer"},
            {"id": "currency_id.name", "name": "Currency", "type": "string", "required": True, "description": "Display name for invoice currency.", "example": "NGN", "category": "amounts"},
            {"id": "currency_id.symbol", "name": "Currency Symbol", "type": "string", "required": False, "description": "Symbol associated with the selected currency.", "example": "â‚¦", "category": "amounts"},
            {"id": "amount_untaxed", "name": "Amount Untaxed", "type": "number", "required": True, "description": "Subtotal before any taxes are applied.", "example": 1250000.00, "category": "amounts"},
            {"id": "amount_tax", "name": "Tax Amount", "type": "number", "required": False, "description": "Total VAT amount computed by Odoo.", "example": 93750.00, "category": "amounts"},
            {"id": "amount_total", "name": "Total Amount", "type": "number", "required": True, "description": "Grand total including taxes.", "example": 1343750.00, "category": "amounts"},
            {"id": "payment_state", "name": "Payment Status", "type": "string", "required": False, "description": "Draft, paid, partial, not_paid, etc.", "example": "not_paid", "category": "metadata"},
            {"id": "state", "name": "Invoice State", "type": "string", "required": False, "description": "Workflow state (draft, posted, etc.).", "example": "posted", "category": "metadata"},
            {"id": "company_id.vat", "name": "Company VAT/TIN", "type": "string", "required": False, "description": "Selling company's tax identification number from res.company.", "example": "09876543-0001", "category": "metadata"},
            {"id": "invoice_line_ids[].product_id.display_name", "name": "Line Product", "type": "string", "required": True, "description": "Display name for the product or service.", "example": "Premium Cement 50KG", "category": "lines"},
            {"id": "invoice_line_ids", "name": "Invoice Lines Collection", "type": "array", "required": True, "description": "Raw invoice line records (account.move.line).", "category": "lines"},
            {"id": "invoice_line_ids[].name", "name": "Line Description", "type": "string", "required": False, "description": "Additional description appearing on the line.", "example": "Premium Cement 50KG bag", "category": "lines"},
            {"id": "invoice_line_ids[].quantity", "name": "Line Quantity", "type": "number", "required": True, "description": "Quantity sold for the line item.", "example": 250, "category": "lines"},
            {"id": "invoice_line_ids[].product_uom_id.name", "name": "Line Unit of Measure", "type": "string", "required": False, "description": "UoM attached to the line.", "example": "Bag(s)", "category": "lines"},
            {"id": "invoice_line_ids[].price_unit", "name": "Line Unit Price", "type": "number", "required": True, "description": "Unit price before discounts or taxes.", "example": 5000.0, "category": "lines"},
            {"id": "invoice_line_ids[].price_subtotal", "name": "Line Subtotal", "type": "number", "required": True, "description": "Subtotal exclusive of taxes for the line.", "example": 1250000.0, "category": "lines"},
            {"id": "invoice_line_ids[].tax_ids[].name", "name": "Line Tax Name", "type": "string", "required": False, "description": "Tax label applied to the line.", "example": "VAT 7.5%", "category": "lines"},
            {"id": "invoice_line_ids[].tax_ids[].amount", "name": "Line Tax Rate", "type": "number", "required": False, "description": "VAT percentage for the line item.", "example": 7.5, "category": "lines"},
        ],
        "default_mappings": {
            "invoice_number": "name",
            "invoice_date": "invoice_date",
            "supplier_tin": "company_id.vat",
            "customer_tin": "partner_id.vat",
            "line_items": "invoice_line_ids",
            "total_amount": "amount_total",
            "vat_amount": "amount_tax",
            "currency": "currency_id.name"
        }
    },
    "sap": {
        "system_id": "sap",
        "system_name": "SAP ERP",
        "version": "S/4HANA 2023",
        "description": "SAP SD BillingDocument payload used for FIRS UBL BIS 3.0 transformation.",
        "categories": [
            {"id": "header", "label": "Billing Document Header"},
            {"id": "customer", "label": "Customer & Partner"},
            {"id": "amounts", "label": "Amounts & Taxes"},
            {"id": "metadata", "label": "Company Metadata"},
            {"id": "logistics", "label": "Logistics & References"},
            {"id": "lines", "label": "Line Items"}
        ],
        "fields": [
            {"id": "BillingDocument", "name": "Billing Document Number", "type": "string", "required": True, "description": "Primary SAP billing document identifier (VBELN).", "example": "0090000123", "category": "header"},
            {"id": "BillingDocumentDate", "name": "Billing Document Date", "type": "date", "required": True, "description": "Document date (FKDAT).", "example": "2024-03-18", "category": "header"},
            {"id": "BillingDocumentType", "name": "Billing Document Type", "type": "string", "required": True, "description": "Document type (FKART) e.g. F2 (Invoice).", "example": "F2", "category": "header"},
            {"id": "SalesOrganization", "name": "Sales Organization", "type": "string", "required": False, "description": "Sales organization responsible for billing document.", "example": "1000", "category": "header"},
            {"id": "DistributionChannel", "name": "Distribution Channel", "type": "string", "required": False, "description": "Distribution channel (VTWEG).", "example": "10", "category": "header"},
            {"id": "Division", "name": "Division", "type": "string", "required": False, "description": "Division (SPART).", "example": "01", "category": "header"},
            {"id": "CompanyTaxNumber", "name": "Company VAT Number", "type": "string", "required": False, "description": "Tax identification number for the issuing company (CompanyCode VAT).", "example": "54321098-0001", "category": "metadata"},
            {"id": "SoldToParty", "name": "Sold-To Party", "type": "string", "required": True, "description": "Business partner customer number (KUNAG).", "example": "CUST-1030001", "category": "customer"},
            {"id": "PayerParty", "name": "Payer Party", "type": "string", "required": False, "description": "Payer account number (KUNRG).", "example": "CUST-1030001", "category": "customer"},
            {"id": "CustomerName", "name": "Customer Name", "type": "string", "required": False, "description": "Resolved name for sold-to party.", "example": "MTN Nigeria Communications PLC", "category": "customer"},
            {"id": "CustomerVATRegistration", "name": "Customer VAT Number", "type": "string", "required": False, "description": "Customer's VAT/TIN captured in SAP.", "example": "12345678-0002", "category": "customer"},
            {"id": "TotalNetAmount", "name": "Net Amount", "type": "number", "required": True, "description": "Total net amount in document currency (NETWR).", "example": 1540000.00, "category": "amounts"},
            {"id": "TotalTaxAmount", "name": "Tax Amount", "type": "number", "required": False, "description": "Total tax calculated for the document.", "example": 115500.00, "category": "amounts"},
            {"id": "TotalGrossAmount", "name": "Gross Amount", "type": "number", "required": True, "description": "Gross amount (brutto) including taxes.", "example": 1655500.00, "category": "amounts"},
            {"id": "TransactionCurrency", "name": "Document Currency", "type": "string", "required": True, "description": "Currency key (WAERK).", "example": "NGN", "category": "amounts"},
            {"id": "ExchangeRate", "name": "Exchange Rate", "type": "number", "required": False, "description": "Applicable exchange rate for the document.", "example": 1.0, "category": "amounts"},
            {"id": "PaymentTerms", "name": "Payment Terms", "type": "string", "required": False, "description": "Payment terms key (ZTERM).", "example": "0001", "category": "header"},
            {"id": "ReferenceDocument", "name": "Reference Document", "type": "string", "required": False, "description": "Reference doc number (XBLNR).", "example": "PO-9002341", "category": "logistics"},
            {"id": "PODate", "name": "Customer PO Date", "type": "date", "required": False, "description": "Customer purchase order date.", "example": "2024-03-05", "category": "logistics"},
            {"id": "ShippingPoint", "name": "Shipping Point", "type": "string", "required": False, "description": "Shipping point (VSTEL).", "example": "SHIP-001", "category": "logistics"},
            {"id": "InvoiceItems[].ItemNumber", "name": "Item Number", "type": "string", "required": True, "description": "Billing item number (POSNR).", "example": "000010", "category": "lines"},
            {"id": "InvoiceItems[].MaterialNumber", "name": "Material Number", "type": "string", "required": True, "description": "Material number (MATNR).", "example": "MAT-41001234", "category": "lines"},
            {"id": "InvoiceItems[].MaterialDescription", "name": "Material Description", "type": "string", "required": False, "description": "Description copied from material master.", "example": "Premium Diesel Supply", "category": "lines"},
            {"id": "InvoiceItems[].Quantity", "name": "Billing Quantity", "type": "number", "required": True, "description": "Quantity billed (FKIMG).", "example": 1200.0, "category": "lines"},
            {"id": "InvoiceItems[].BaseUnit", "name": "Base Unit", "type": "string", "required": False, "description": "Base unit of measure (MEINS).", "example": "LTR", "category": "lines"},
            {"id": "InvoiceItems[].NetAmount", "name": "Net Amount (Item)", "type": "number", "required": True, "description": "Net amount for the item.", "example": 1280000.00, "category": "lines"},
            {"id": "InvoiceItems[].TaxAmount", "name": "Tax Amount (Item)", "type": "number", "required": False, "description": "Tax amount for the item.", "example": 96000.00, "category": "lines"},
            {"id": "InvoiceItems[].TaxCode", "name": "Tax Code", "type": "string", "required": False, "description": "Item specific tax code (TAXM1/TXJCD).", "example": "UTXJ", "category": "lines"},
            {"id": "InvoiceItems[].Plant", "name": "Plant", "type": "string", "required": False, "description": "Supplying plant (WERKS).", "example": "PLNT-1000", "category": "logistics"},
            {"id": "InvoiceItems", "name": "Invoice Items Collection", "type": "array", "required": True, "description": "Raw invoice item records from SAP BillingDocument API.", "category": "lines"},
        ],
        "default_mappings": {
            "invoice_number": "BillingDocument",
            "invoice_date": "BillingDocumentDate",
            "supplier_tin": "CompanyTaxNumber",
            "customer_tin": "CustomerVATRegistration",
            "line_items": "InvoiceItems",
            "total_amount": "TotalGrossAmount",
            "vat_amount": "TotalTaxAmount",
            "currency": "TransactionCurrency"
        }
    },
    "quickbooks": {
        "system_id": "quickbooks",
        "system_name": "QuickBooks Online",
        "version": "v3 API",
        "description": "QuickBooks Invoice schema exposed through the Intuit accounting API.",
        "categories": [
            {"id": "header", "label": "Invoice Header"},
            {"id": "customer", "label": "Customer"},
            {"id": "amounts", "label": "Amounts & Taxes"},
            {"id": "metadata", "label": "Metadata"},
            {"id": "lines", "label": "Line Items"}
        ],
        "fields": [
            {"id": "DocNumber", "name": "Document Number", "type": "string", "required": True, "description": "Invoice number assigned in QuickBooks.", "example": "INV-1045", "category": "header"},
            {"id": "TxnDate", "name": "Transaction Date", "type": "date", "required": True, "description": "Invoice creation date.", "example": "2024-03-18", "category": "header"},
            {"id": "DueDate", "name": "Due Date", "type": "date", "required": False, "description": "Invoice due date.", "example": "2024-04-17", "category": "header"},
            {"id": "TxnStatus", "name": "Transaction Status", "type": "string", "required": False, "description": "Status string (Draft, Paid, etc.).", "example": "Open", "category": "metadata"},
            {"id": "PrivateNote", "name": "Private Note", "type": "string", "required": False, "description": "Internal notes for the invoice.", "example": "Deliver between 8-10am", "category": "metadata"},
            {"id": "CustomerRef.value", "name": "Customer ID", "type": "string", "required": True, "description": "Reference ID for the customer.", "example": "123", "category": "customer"},
            {"id": "CustomerRef.name", "name": "Customer Name", "type": "string", "required": False, "description": "Display name for the customer.", "example": "Flour Mills of Nigeria Plc", "category": "customer"},
            {"id": "BillAddr.Line1", "name": "Billing Address Line 1", "type": "string", "required": False, "description": "Primary billing address line.", "example": "1 Golden Penny Way", "category": "customer"},
            {"id": "BillEmail.Address", "name": "Customer Email", "type": "string", "required": False, "description": "Email address on file.", "example": "ap@flourmills.com", "category": "customer"},
            {"id": "CurrencyRef.value", "name": "Currency Code", "type": "string", "required": True, "description": "Currency code defined for the invoice.", "example": "NGN", "category": "amounts"},
            {"id": "ExchangeRate", "name": "Exchange Rate", "type": "number", "required": False, "description": "Exchange rate relative to home currency.", "example": 1.0, "category": "amounts"},
            {"id": "TotalAmt", "name": "Total Amount", "type": "number", "required": True, "description": "Invoice total including taxes and discounts.", "example": 840000.00, "category": "amounts"},
            {"id": "Balance", "name": "Outstanding Balance", "type": "number", "required": False, "description": "Outstanding balance remaining.", "example": 840000.00, "category": "amounts"},
            {"id": "TxnTaxDetail.TotalTax", "name": "Total Tax", "type": "number", "required": False, "description": "Aggregate tax amount computed by QuickBooks.", "example": 63000.00, "category": "amounts"},
            {"id": "Line", "name": "Invoice Lines Collection", "type": "array", "required": True, "description": "Raw invoice line objects returned by QuickBooks.", "category": "lines"},
            {"id": "Line[].Description", "name": "Line Description", "type": "string", "required": False, "description": "Description of the product/service sold.", "example": "Enterprise support retainers", "category": "lines"},
            {"id": "Line[].SalesItemLineDetail.ItemRef.name", "name": "Line Item Name", "type": "string", "required": True, "description": "Item name from QuickBooks item list.", "example": "Support Retainer", "category": "lines"},
            {"id": "Line[].SalesItemLineDetail.ItemRef.value", "name": "Line Item ID", "type": "string", "required": True, "description": "Item ID reference.", "example": "25", "category": "lines"},
            {"id": "Line[].SalesItemLineDetail.Qty", "name": "Line Quantity", "type": "number", "required": True, "description": "Quantity sold for the line.", "example": 12, "category": "lines"},
            {"id": "Line[].SalesItemLineDetail.UnitPrice", "name": "Line Unit Price", "type": "number", "required": True, "description": "Unit price for the line.", "example": 70000.00, "category": "lines"},
            {"id": "Line[].Amount", "name": "Line Amount", "type": "number", "required": True, "description": "Line amount before tax.", "example": 840000.00, "category": "lines"},
            {"id": "Line[].SalesItemLineDetail.TaxCodeRef.value", "name": "Line Tax Code", "type": "string", "required": False, "description": "Tax code reference for the line.", "example": "TAX", "category": "lines"}
        ],
        "default_mappings": {
            "invoice_number": "DocNumber",
            "invoice_date": "TxnDate",
            "line_items": "Line",
            "total_amount": "TotalAmt",
            "vat_amount": "TxnTaxDetail.TotalTax",
            "currency": "CurrencyRef.value"
        }
    }
}

DEFAULT_FIRS_SCHEMA: List[Dict[str, Any]] = [
    {"id": "invoice_number", "required": True},
    {"id": "invoice_date", "required": True},
    {"id": "supplier_tin", "required": True},
    {"id": "customer_tin", "required": False},
    {"id": "line_items", "required": True},
    {"id": "total_amount", "required": True},
    {"id": "vat_amount", "required": False},
    {"id": "currency", "required": True},
]


class MappingTransformationModel(BaseModel):
    type: Literal["direct", "format", "calculate", "lookup", "conditional"]
    formula: Optional[str] = None
    lookup_table: Optional[Dict[str, Any]] = Field(default=None, alias="lookupTable")
    conditions: Optional[List[Dict[str, Any]]] = None

    class Config:
        allow_population_by_field_name = True
        extra = "allow"


class MappingRuleModel(BaseModel):
    id: str
    source_field: str = Field(..., alias="sourceField")
    target_field: str = Field(..., alias="targetField")
    source_label: Optional[str] = Field(default=None, alias="sourceLabel")
    transformation: Optional[MappingTransformationModel] = None
    validated: bool = Field(default=False, alias="validated")

    class Config:
        allow_population_by_field_name = True
        extra = "allow"


class FIRSFieldModel(BaseModel):
    id: str
    required: bool = False

    class Config:
        extra = "allow"


class ValidateMappingRequest(BaseModel):
    system_id: str = Field(..., alias="system_id")
    organization_id: Optional[str] = Field(default=None, alias="organization_id")
    mapping_rules: List[MappingRuleModel] = Field(..., alias="mapping_rules")
    firs_schema: List[FIRSFieldModel] = Field(default_factory=list, alias="firs_schema")

    class Config:
        allow_population_by_field_name = True
        extra = "allow"


class SaveMappingRequest(BaseModel):
    system_id: str = Field(..., alias="system_id")
    organization_id: Optional[str] = Field(default=None, alias="organization_id")
    mapping_rules: List[MappingRuleModel] = Field(..., alias="mapping_rules")

    class Config:
        allow_population_by_field_name = True
        extra = "allow"


class ERPEndpointsV1:
    """
    ERP System Integration Endpoints - Version 1
    ============================================
    Manages ERP system integrations for System Integrators:
    
    **Available ERP Systems:**
    - **SAP**: Enterprise-grade ERP with OData API integration
    - **Oracle**: Comprehensive business suite with REST APIs
    - **Microsoft Dynamics**: Cloud and on-premise ERP solutions
    - **NetSuite**: Cloud-based ERP platform
    - **Odoo**: Open-source business management suite
    
    **ERP Features:**
    - Invoice data extraction and processing
    - Customer and vendor management
    - Product catalog synchronization
    - Financial data integration
    - Real-time data synchronization
    """
    
    def __init__(self, 
                 role_detector: HTTPRoleDetector,
                 permission_guard: APIPermissionGuard,
                 message_router: MessageRouter,
                 onboarding_service: Optional[SIOnboardingService] = None):
        self.role_detector = role_detector
        self.permission_guard = permission_guard
        self.message_router = message_router
        self.router = APIRouter(prefix="/erp", tags=["ERP Systems V1"])
        self.onboarding_service = onboarding_service or SIOnboardingService()
        
        # Available ERP systems from actual implementation
        self.erp_systems = {
            "sap": {
                "name": "SAP ERP",
                "description": "Enterprise-grade ERP with OData API integration",
                "auth_methods": ["oauth2", "basic_auth"],
                "data_types": ["invoices", "customers", "vendors", "products", "financial_data"],
                "api_type": "odata",
                "documentation": "/docs/integrations/erp/sap"
            },
            "oracle": {
                "name": "Oracle ERP Cloud",
                "description": "Comprehensive business suite with REST APIs",
                "auth_methods": ["oauth2", "jwt"],
                "data_types": ["invoices", "customers", "vendors", "products", "financial_data"],
                "api_type": "rest",
                "documentation": "/docs/integrations/erp/oracle"
            },
            "dynamics": {
                "name": "Microsoft Dynamics",
                "description": "Cloud and on-premise ERP solutions",
                "auth_methods": ["oauth2", "azure_ad"],
                "data_types": ["invoices", "customers", "vendors", "products", "financial_data"],
                "api_type": "rest",
                "documentation": "/docs/integrations/erp/dynamics"
            },
            "netsuite": {
                "name": "NetSuite ERP",
                "description": "Cloud-based comprehensive ERP platform",
                "auth_methods": ["oauth2", "token_based"],
                "data_types": ["invoices", "customers", "vendors", "products", "financial_data"],
                "api_type": "rest",
                "documentation": "/docs/integrations/erp/netsuite"
            },
            "odoo": {
                "name": "Odoo",
                "description": "Open-source business management suite",
                "auth_methods": ["api_key", "session_auth"],
                "data_types": ["invoices", "customers", "vendors", "products", "financial_data"],
                "api_type": "xmlrpc",
                "documentation": "/docs/integrations/erp/odoo"
            }
        }
        
        self._setup_routes()
        logger.info("ERP Endpoints V1 initialized")
    
    def _setup_routes(self):
        """Setup ERP system integration routes"""
        guard_deps: List[Any] = []
        protected_guard_deps: List[Any] = [Depends(self._ensure_context)]
        
        # ERP System Discovery
        self.router.add_api_route(
            "/available",
            self.get_available_erp_systems,
            methods=["GET"],
            summary="Get available ERP systems",
            description="List all ERP systems available for integration",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        # ERP Connection Management
        self.router.add_api_route(
            "/connections",
            self.list_erp_connections,
            methods=["GET"],
            summary="List ERP connections",
            description="Get all ERP system connections for the SI",
            response_model=V1ResponseModel,
            dependencies=protected_guard_deps,
        )
        
        self.router.add_api_route(
            "/connections",
            self.create_erp_connection,
            methods=["POST"],
            summary="Create ERP connection",
            description="Create new ERP system connection",
            response_model=V1ResponseModel,
            status_code=201,
            dependencies=protected_guard_deps,
        )
        
        self.router.add_api_route(
            "/test-credentials",
            self.test_erp_connection_credentials,
            methods=["POST"],
            summary="Test ERP connection credentials",
            description="Validate ERP credentials without creating a persistent connection",
            response_model=V1ResponseModel,
            dependencies=protected_guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}",
            self.get_erp_connection,
            methods=["GET"],
            summary="Get ERP connection",
            description="Get specific ERP connection details",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}",
            self.update_erp_connection,
            methods=["PUT"],
            summary="Update ERP connection",
            description="Update ERP connection configuration",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}",
            self.delete_erp_connection,
            methods=["DELETE"],
            summary="Delete ERP connection",
            description="Remove ERP connection",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        # ERP Connection Testing
        self.router.add_api_route(
            "/connections/{connection_id}/test",
            self.test_erp_connection,
            methods=["POST"],
            summary="Test ERP connection",
            description="Test connectivity and authentication for ERP connection",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/health",
            self.get_erp_connection_health,
            methods=["GET"],
            summary="Get ERP connection health",
            description="Get detailed health status of ERP connection",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        # ERP Data Synchronization
        self.router.add_api_route(
            "/connections/{connection_id}/sync",
            self.sync_erp_data,
            methods=["POST"],
            summary="Sync ERP data",
            description="Synchronize data from ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/sync-status",
            self.get_erp_sync_status,
            methods=["GET"],
            summary="Get ERP sync status",
            description="Get status of ERP data synchronization",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        # ERP Data Extraction
        self.router.add_api_route(
            "/connections/{connection_id}/invoices",
            self.get_erp_invoices,
            methods=["GET"],
            summary="Get ERP invoices",
            description="Extract invoices from ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/customers",
            self.get_erp_customers,
            methods=["GET"],
            summary="Get ERP customers",
            description="Extract customers from ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/products",
            self.get_erp_products,
            methods=["GET"],
            summary="Get ERP products",
            description="Extract products from ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/financial-data",
            self.get_erp_financial_data,
            methods=["GET"],
            summary="Get ERP financial data",
            description="Extract financial data from ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        # ERP Schema and Mapping
        self.router.add_api_route(
            "/{erp_system}/schema",
            self.get_erp_schema,
            methods=["GET"],
            summary="Get ERP schema",
            description="Get data schema for specific ERP system",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/field-mapping",
            self.get_erp_field_mapping,
            methods=["GET"],
            summary="Get ERP field mapping",
            description="Get field mapping configuration for ERP connection",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/connections/{connection_id}/field-mapping",
            self.update_erp_field_mapping,
            methods=["PUT"],
            summary="Update ERP field mapping",
            description="Update field mapping configuration for ERP connection",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )

        # ERP Data Mapping Workflow
        self.router.add_api_route(
            "/data-mapping/validate",
            self.validate_data_mapping,
            methods=["POST"],
            summary="Validate ERP to FIRS data mapping",
            description="Validate ERP mapping rules against canonical ERP schema and FIRS requirements",
            response_class=JSONResponse,
            dependencies=protected_guard_deps,
        )
        self.router.add_api_route(
            "/data-mapping/save",
            self.save_data_mapping,
            methods=["POST"],
            summary="Persist ERP data mapping configuration",
            description="Persist validated ERP mapping rules within onboarding metadata",
            response_class=JSONResponse,
            dependencies=protected_guard_deps,
        )
        self.router.add_api_route(
            "/data-mapping/{organization_id}/{system_id}",
            self.get_saved_data_mapping,
            methods=["GET"],
            summary="Retrieve saved ERP data mapping rules",
            description="Fetch previously saved mapping configuration for an organization/system pair",
            response_class=JSONResponse,
            dependencies=protected_guard_deps,
        )
        
        # Bulk Operations
        self.router.add_api_route(
            "/bulk/test-connections",
            self.bulk_test_erp_connections,
            methods=["POST"],
            summary="Bulk test ERP connections",
            description="Test multiple ERP connections at once",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        
        self.router.add_api_route(
            "/bulk/sync-data",
            self.bulk_sync_erp_data,
            methods=["POST"],
            summary="Bulk sync ERP data",
            description="Synchronize data from multiple ERP systems",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )

        # Test fetch paths (Odoo â†’ FIRS transform) for preâ€‘submission validation
        self.router.add_api_route(
            "/odoo/test-fetch-invoices",
            self.test_fetch_invoices,
            methods=["POST"],
            summary="Test-fetch specific Odoo invoices",
            description="Fetch and transform specific Odoo invoices via SI to FIRS-compliant payloads",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )
        self.router.add_api_route(
            "/odoo/test-fetch-batch",
            self.test_fetch_invoice_batch,
            methods=["POST"],
            summary="Test-fetch Odoo invoice batch",
            description="Fetch and transform a batch of Odoo invoices via SI to FIRS-compliant payloads",
            response_model=V1ResponseModel,
            dependencies=guard_deps,
        )

    async def _require_si_role(self, request: Request) -> HTTPRoutingContext:
        """Ensure System Integrator role access for v1 SI endpoints."""
        context = await self.role_detector.detect_role_context(request)
        if not context or not await self.permission_guard.check_endpoint_permission(
            context, f"v1/si{request.url.path}", request.method
        ):
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient permissions for SI v1 endpoint")
        context.metadata["api_version"] = "v1"
        context.metadata["endpoint_group"] = "si"
        return context

    async def _get_si_context(self, request: Request) -> HTTPRoutingContext:
        """Fetch SI routing context from request state with fallback detection."""
        context = getattr(request.state, "routing_context", None)
        if isinstance(context, HTTPRoutingContext):
            return context
        return await self._require_si_role(request)

    async def _ensure_context(self, request: Request) -> HTTPRoutingContext:
        """Ensure routing context is present when used as a dependency."""
        return await self._get_si_context(request)

    @staticmethod
    def _iso_now() -> str:
        return datetime.now(timezone.utc).isoformat()

    @staticmethod
    def _normalize_system_key(system_id: str) -> str:
        return (system_id or "").strip().lower()

    def _get_erp_schema_entry(self, system_id: str) -> Tuple[str, Dict[str, Any]]:
        normalized = self._normalize_system_key(system_id)
        schema = ERP_SCHEMA_DEFINITIONS.get(normalized)
        if not schema:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Unsupported ERP system '{system_id}'",
            )
        return normalized, schema

    @staticmethod
    def _catalog_erp_fields(schema: Dict[str, Any]) -> Set[str]:
        fields: Set[str] = set()
        for item in schema.get("fields", []):
            field_id = item.get("id")
            field_path = item.get("path")
            if field_id:
                fields.add(field_id)
            if field_path:
                fields.add(field_path)
        return fields

    @staticmethod
    def _prepare_firs_schema(firs_schema: List[FIRSFieldModel]) -> List[FIRSFieldModel]:
        if firs_schema:
            return firs_schema
        return [FIRSFieldModel(**field) for field in DEFAULT_FIRS_SCHEMA]

    def _evaluate_mapping_rules(
        self,
        system_id: str,
        mapping_rules: List[MappingRuleModel],
        firs_schema: List[FIRSFieldModel],
    ) -> Tuple[Dict[str, List[str]], Dict[str, str], Set[str], Dict[str, bool]]:
        _, schema = self._get_erp_schema_entry(system_id)
        erp_fields = self._catalog_erp_fields(schema)

        firs_models = self._prepare_firs_schema(firs_schema)
        firs_requirements = {field.id: field.required for field in firs_models}

        errors: Dict[str, List[str]] = {}
        preview_map: Dict[str, str] = {}
        mapped_targets: Set[str] = set()
        seen_targets: Set[str] = set()

        if not mapping_rules:
            errors["__root__"] = ["At least one mapping rule is required."]
            return errors, preview_map, mapped_targets, firs_requirements

        for rule in mapping_rules:
            target = (rule.target_field or "").strip()
            source = (rule.source_field or "").strip()
            rule_errors: List[str] = []

            if not target:
                rule_errors.append("Target field is required.")
            if not source:
                rule_errors.append("Source field is required.")

            if target:
                if target in seen_targets:
                    rule_errors.append("Target field already mapped.")
                seen_targets.add(target)

                if target not in firs_requirements:
                    rule_errors.append("Unknown target field for FIRS mapping.")

            if source and source not in erp_fields:
                rule_errors.append("Source field not present in ERP schema.")

            if rule_errors:
                errors.setdefault(target or rule.id, []).extend(rule_errors)
                continue

            preview_map[target] = source
            mapped_targets.add(target)

        for target, required in firs_requirements.items():
            if required and target not in mapped_targets:
                errors.setdefault(target, []).append("Required field missing mapping.")

        for key, messages in list(errors.items()):
            deduped = sorted({msg for msg in messages if msg})
            if deduped:
                errors[key] = deduped
            else:
                errors.pop(key, None)

        return errors, preview_map, mapped_targets, firs_requirements

    @staticmethod
    def _serialize_mapping_rules(mapping_rules: List[MappingRuleModel]) -> List[Dict[str, Any]]:
        return [
            rule.dict(by_alias=True, exclude_none=True)
            for rule in mapping_rules
        ]

    async def _load_onboarding_state(
        self,
        user_id: str,
        service_package: str,
    ) -> Dict[str, Any]:
        try:
            response = await self.onboarding_service.handle_operation(
                "get_onboarding_state",
                {"user_id": user_id, "service_package": service_package},
            )
        except Exception as exc:
            logger.error("Failed to fetch onboarding state for user %s: %s", user_id, exc, exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Unable to load onboarding state for data mapping",
            ) from exc

        if not response.get("success"):
            return {}
        return response.get("data") or {}

    async def _persist_mapping_metadata(
        self,
        user_id: str,
        service_package: str,
        metadata: Dict[str, Any],
        *,
        current_step: Optional[str],
        completed_steps: List[str],
    ) -> None:
        payload = {
            "user_id": user_id,
            "service_package": service_package,
            "onboarding_data": {
                "current_step": current_step or "data_mapping",
                "completed_steps": completed_steps,
                "metadata": metadata,
            },
        }

        try:
            response = await self.onboarding_service.handle_operation("update_onboarding_state", payload)
        except Exception as exc:
            logger.error("Failed to persist data mapping metadata for user %s: %s", user_id, exc, exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Unable to persist data mapping configuration",
            ) from exc

        if not response.get("success"):
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Failed to save data mapping configuration",
            )

    async def validate_data_mapping(
        self,
        request_model: ValidateMappingRequest,
        request: Request,
    ) -> JSONResponse:
        context = await self._get_si_context(request)
        errors, preview_map, mapped_targets, firs_requirements = self._evaluate_mapping_rules(
            request_model.system_id,
            request_model.mapping_rules,
            request_model.firs_schema,
        )

        missing_required = [
            field_id
            for field_id, required in firs_requirements.items()
            if required and field_id not in mapped_targets
        ]

        response: Dict[str, Any] = {
            "success": not errors,
            "errors": errors if errors else {},
            "preview_data": {
                "system_id": self._normalize_system_key(request_model.system_id),
                "mapped_fields": preview_map,
                "validated_targets": sorted(mapped_targets),
                "missing_required": missing_required,
                "validated_at": self._iso_now(),
            },
        }

        if request_model.organization_id:
            response["organization_id"] = request_model.organization_id
        if context and context.user_id:
            response["validated_by"] = context.user_id

        return JSONResponse(response)

    async def save_data_mapping(
        self,
        request_model: SaveMappingRequest,
        request: Request,
    ) -> JSONResponse:
        context = await self._get_si_context(request)
        organization_id = request_model.organization_id
        if not organization_id:
            if context.organization_id:
                organization_id = str(context.organization_id)
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Organization ID is required to save data mapping",
                )

        user_id = context.user_id
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Authenticated user context required for data mapping",
            )

        errors, preview_map, mapped_targets, firs_requirements = self._evaluate_mapping_rules(
            request_model.system_id,
            request_model.mapping_rules,
            [],
        )

        if errors:
            return JSONResponse(
                {
                    "success": False,
                    "errors": errors,
                    "preview_data": {
                        "system_id": self._normalize_system_key(request_model.system_id),
                        "mapped_fields": preview_map,
                        "missing_required": [
                            field
                            for field, required in firs_requirements.items()
                            if required and field not in mapped_targets
                        ],
                        "validated_at": self._iso_now(),
                    },
                }
            )

        service_package = context.metadata.get("service_package") if context else None
        service_package = service_package or "si"

        state = await self._load_onboarding_state(user_id, service_package)
        metadata = dict(state.get("metadata") or {})
        data_mapping_store = dict(metadata.get("data_mapping") or {})

        system_key = self._normalize_system_key(request_model.system_id)
        serialized_rules = self._serialize_mapping_rules(request_model.mapping_rules)
        updated_at = self._iso_now()

        data_mapping_store[system_key] = {
            "system_id": system_key,
            "organization_id": organization_id,
            "mapping_rules": serialized_rules,
            "validated_targets": sorted(mapped_targets),
            "updated_at": updated_at,
        }

        metadata["data_mapping"] = data_mapping_store
        completed_steps = list(state.get("completed_steps") or [])
        if "data_mapping" not in completed_steps:
            completed_steps.append("data_mapping")

        await self._persist_mapping_metadata(
            user_id,
            service_package,
            metadata,
            current_step="data_mapping",
            completed_steps=completed_steps,
        )

        response = {
            "success": True,
            "saved": True,
            "system_id": system_key,
            "organization_id": organization_id,
            "stored_at": updated_at,
            "validated_targets": sorted(mapped_targets),
        }
        return JSONResponse(response)

    async def get_saved_data_mapping(
        self,
        organization_id: str,
        system_id: str,
        request: Request,
    ) -> JSONResponse:
        context = await self._get_si_context(request)
        if context.organization_id:
            context_org = str(context.organization_id)
            if context_org != organization_id:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Requested organization does not match authenticated context",
                )

        user_id = context.user_id
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Authenticated user context required to fetch data mapping",
            )

        service_package = context.metadata.get("service_package") if context else None
        service_package = service_package or "si"

        state = await self._load_onboarding_state(user_id, service_package)
        metadata = state.get("metadata") or {}
        data_mapping_store = metadata.get("data_mapping") or {}

        system_key = self._normalize_system_key(system_id)
        entry = data_mapping_store.get(system_key)

        if entry and entry.get("organization_id") and entry["organization_id"] != organization_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Data mapping is not available for the requested organization",
            )

        response = {
            "success": True,
            "system_id": system_key,
            "organization_id": organization_id,
            "mapping_rules": entry.get("mapping_rules", []) if entry else [],
            "updated_at": entry.get("updated_at") if entry else None,
        }
        return JSONResponse(response)
    
    # ERP System Discovery
    async def get_available_erp_systems(self, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get available ERP systems"""
        try:
            result = {
                "erp_systems": self.erp_systems,
                "total_count": len(self.erp_systems),
                "system_names": list(self.erp_systems.keys()),
                "supported_features": [
                    "invoice_data_extraction",
                    "customer_management",
                    "product_synchronization", 
                    "financial_data_integration",
                    "real_time_sync",
                    "field_mapping_customization"
                ]
            }
            
            return self._create_v1_response(result, "available_erp_systems_retrieved")
        except Exception as e:
            logger.error(f"Error getting available ERP systems in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to get available ERP systems")
    
    # ERP Connection Management
    async def list_erp_connections(self, 
                                  request: Request,
                                  organization_id: Optional[str] = Query(None, description="Filter by organization"),
                                  erp_system: Optional[str] = Query(None, description="Filter by ERP system"),
                                  status: Optional[str] = Query(None, description="Filter by connection status"),
                                  context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """List ERP connections"""
        try:
            context = context or await self._get_si_context(request)
            # Validate ERP system if provided
            if erp_system and erp_system not in self.erp_systems:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid ERP system. Available: {', '.join(self.erp_systems.keys())}"
                )
            
            payload = {
                "si_id": context.user_id,
                "filters": {
                    "organization_id": organization_id,
                    "erp_system": erp_system,
                    "status": status
                },
                "api_version": "v1"
            }
            result = await self._route_with_si_retry("list_erp_connections", payload)
            
            return self._create_v1_response(result, "erp_connections_listed")
        except HTTPException:
            raise
        except RuntimeError as e:
            logger.error(f"Error listing ERP connections in v1: {e}")
            raise HTTPException(status_code=503, detail="SI services are unavailable. Please try again shortly.")
        except Exception as e:
            logger.error(f"Error listing ERP connections in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to list ERP connections")
    
    async def create_erp_connection(self, 
                                   request: Request,
                                   context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Create ERP connection"""
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
            
            # Validate required fields
            required_fields = ["erp_system", "organization_id", "connection_config"]
            missing_fields = [field for field in required_fields if field not in body]
            if missing_fields:
                raise HTTPException(
                    status_code=400,
                    detail=f"Missing required fields: {', '.join(missing_fields)}"
                )
            
            # Validate ERP system
            if body["erp_system"] not in self.erp_systems:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid ERP system. Available: {', '.join(self.erp_systems.keys())}"
                )
            
            payload = {
                "connection_data": body,
                "si_id": context.user_id,
                "system_type": "erp",
                "api_version": "v1"
            }
            result = await self._route_with_si_retry("create_erp_connection", payload)
            
            return self._create_v1_response(result, "erp_connection_created", status_code=201)
        except HTTPException:
            raise
        except RuntimeError as e:
            logger.error(f"Error creating ERP connection in v1: {e}")
            raise HTTPException(status_code=503, detail="SI services are unavailable. Please try again shortly.")
        except Exception as e:
            logger.error(f"Error creating ERP connection in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to create ERP connection")
    
    async def test_erp_connection_credentials(
        self,
        request: Request,
        context: Optional[HTTPRoutingContext] = Depends(lambda: None),
    ):
        """Test ERP credentials without persisting a connection record."""
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
            
            erp_system = (body.get("erp_system") or "").lower()
            credentials = body.get("credentials")
            
            if not erp_system:
                raise HTTPException(status_code=400, detail="erp_system is required")
            if not isinstance(credentials, dict) or not credentials:
                raise HTTPException(status_code=400, detail="credentials payload is required")
            
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="test_erp_connection_credentials",
                payload={
                    "erp_system": erp_system,
                    "credentials": credentials,
                    "organization_id": body.get("organization_id"),
                    "si_id": context.user_id,
                    "api_version": "v1",
                },
            )
            
            return self._create_v1_response(result, "erp_connection_credentials_tested")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error testing ERP credentials in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to test ERP credentials")
    
    async def get_erp_connection(self, 
                                connection_id: str,
                                request: Request,
                                context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP connection"""
        try:
            context = context or await self._get_si_context(request)
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="get_erp_connection",
                payload={
                    "connection_id": connection_id,
                    "si_id": context.user_id,
                    "include_schema": True,
                    "include_mapping": True,
                    "api_version": "v1"
                }
            )
            
            if not result:
                raise HTTPException(status_code=404, detail="ERP connection not found")
            
            return self._create_v1_response(result, "erp_connection_retrieved")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error getting ERP connection {connection_id} in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to get ERP connection")
    
    # Placeholder implementations for remaining endpoints
    async def update_erp_connection(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="update_erp_connection",
                payload={
                    "connection_id": connection_id,
                    "connection_data": body,
                    "si_id": context.user_id,
                    "api_version": "v1",
                },
            )
            return self._create_v1_response(result, "erp_connection_updated")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error updating ERP connection {connection_id} in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to update ERP connection")

    async def delete_erp_connection(self, connection_id: str, request: Request):
        try:
            context = await self._get_si_context(request)
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="delete_erp_connection",
                payload={
                    "connection_id": connection_id,
                    "si_id": context.user_id,
                    "api_version": "v1",
                },
            )
            return self._create_v1_response(result, "erp_connection_deleted")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error deleting ERP connection {connection_id} in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to delete ERP connection")
    
    async def test_erp_connection(self, connection_id: str, request: Request):
        try:
            context = await self._get_si_context(request)
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="test_erp_connection",
                payload={
                    "connection_id": connection_id,
                    "si_id": context.user_id,
                    "api_version": "v1",
                },
            )
            return self._create_v1_response(result, "erp_connection_tested")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error testing ERP connection {connection_id} in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to test ERP connection")
    
    async def get_erp_connection_health(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="get_erp_connection_health",
                payload={
                    "connection_id": connection_id,
                    "si_id": context.user_id,
                    "api_version": "v1",
                },
            )
            return self._create_v1_response(result, "erp_connection_health_retrieved")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error getting ERP connection health for {connection_id} in v1: {e}")
            raise HTTPException(status_code=502, detail="Failed to get ERP connection health")
    
    async def sync_erp_data(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
        except HTTPException:
            raise
        except Exception as exc:
            logger.error(f"Failed to parse sync payload for {connection_id}: {exc}")
            body = {}

        payload = {
            "connection_id": connection_id,
            "data_type": body.get("data_type", "invoices"),
            "options": body.get("options") or {},
            "force": bool(body.get("force", False)),
            "si_id": context.user_id if context else None,
        }

        try:
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="sync_erp_data",
                payload=payload,
            )
            return self._create_v1_response(result, "erp_data_sync_initiated")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error syncing ERP data for {connection_id}: {e}")
            raise HTTPException(status_code=502, detail="Failed to queue ERP data sync")

    async def get_erp_sync_status(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
        except HTTPException:
            raise
        except Exception:
            context = None

        try:
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="get_erp_sync_status",
                payload={
                    "connection_id": connection_id,
                    "si_id": context.user_id if context else None,
                },
            )
            return self._create_v1_response(result, "erp_sync_status_retrieved")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error retrieving ERP sync status for {connection_id}: {e}")
            raise HTTPException(status_code=502, detail="Failed to retrieve ERP sync status")
    
    async def get_erp_invoices(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP invoices - placeholder"""
        return self._create_v1_response({"invoices": []}, "erp_invoices_retrieved")
    
    async def get_erp_customers(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP customers - placeholder"""
        return self._create_v1_response({"customers": []}, "erp_customers_retrieved")
    
    async def get_erp_products(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP products - placeholder"""
        return self._create_v1_response({"products": []}, "erp_products_retrieved")
    
    async def get_erp_financial_data(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP financial data - placeholder"""
        return self._create_v1_response({"financial_data": []}, "erp_financial_data_retrieved")
    
    async def get_erp_schema(self, erp_system: str, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP schema definition including recommended mappings."""
        system_key = (erp_system or "").lower()

        if system_key not in self.erp_systems:
            raise HTTPException(
                status_code=404,
                detail=f"ERP system not found. Available systems: {', '.join(self.erp_systems.keys())}"
            )

        schema_definition = ERP_SCHEMA_DEFINITIONS.get(system_key)
        if not schema_definition:
            raise HTTPException(
                status_code=404,
                detail="Schema definition not available for the requested ERP system"
            )

        response_payload = {
            "schema": schema_definition,
            "erp_system": self.erp_systems[system_key],
            "generated_at": datetime.utcnow().isoformat() + "Z",
        }
        return self._create_v1_response(response_payload, "erp_schema_retrieved")
    
    async def get_erp_field_mapping(self, connection_id: str, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Get ERP field mapping - placeholder"""
        return self._create_v1_response({"field_mapping": {}}, "erp_field_mapping_retrieved")
    
    async def update_erp_field_mapping(self, connection_id: str, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        """Update ERP field mapping - placeholder"""
        return self._create_v1_response({"connection_id": connection_id}, "erp_field_mapping_updated")
    
    async def bulk_test_erp_connections(self, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="bulk_test_erp_connections",
                payload={
                    "connection_ids": body.get("connection_ids") or [],
                    "options": body.get("options") or {},
                    "si_id": context.user_id,
                },
            )
            return self._create_v1_response(result, "bulk_erp_connection_tests_initiated")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error bulk testing ERP connections: {e}")
            raise HTTPException(status_code=502, detail="Failed to bulk test ERP connections")
    
    async def bulk_sync_erp_data(self, request: Request, context: Optional[HTTPRoutingContext] = Depends(lambda: None)):
        try:
            context = context or await self._get_si_context(request)
            body = await request.json()
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="bulk_sync_erp_data",
                payload={
                    "connection_ids": body.get("connection_ids") or [],
                    "data_type": body.get("data_type", "invoices"),
                    "options": body.get("options") or {},
                    "si_id": context.user_id,
                },
            )
            return self._create_v1_response(result, "bulk_erp_data_sync_initiated")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error bulk syncing ERP data: {e}")
            raise HTTPException(status_code=502, detail="Failed to bulk sync ERP data")

    # Test-fetch helpers (routes above)
    async def test_fetch_invoices(self, request: Request):
        try:
            context = await self._get_si_context(request)
            body = await request.json()
            invoice_ids = body.get("invoice_ids") or []
            if not isinstance(invoice_ids, list) or not invoice_ids:
                raise HTTPException(status_code=400, detail="invoice_ids must be a non-empty list")
            payload = {
                "invoice_ids": invoice_ids,
                "odoo_config": body.get("odoo_config") or {},
                "transform": bool(body.get("transform", True)),
                "target_format": body.get("target_format", "UBL_BIS_3.0"),
            }
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="fetch_odoo_invoices_for_firs",
                payload=payload,
            )
            # Attach summary
            data = result.get("data") if isinstance(result, dict) else {}
            if isinstance(data, dict):
                data["fetched_count"] = len(data.get("invoices") or [])
            return self._create_v1_response(result, "odoo_invoices_fetched_for_firs")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error test-fetching invoices: {e}")
            raise HTTPException(status_code=502, detail="Failed to test-fetch invoices")

    async def test_fetch_invoice_batch(self, request: Request):
        try:
            context = await self._get_si_context(request)
            body = await request.json()
            payload = {
                "batch_size": int(body.get("batch_size", 50)),
                "include_attachments": bool(body.get("include_attachments", False)),
                "odoo_config": body.get("odoo_config") or {},
                "transform": bool(body.get("transform", True)),
                "target_format": body.get("target_format", "UBL_BIS_3.0"),
            }
            result = await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation="fetch_odoo_invoice_batch_for_firs",
                payload=payload,
            )
            data = result.get("data") if isinstance(result, dict) else {}
            if isinstance(data, dict):
                data["fetched_count"] = len(data.get("invoices") or [])
            return self._create_v1_response(result, "odoo_invoice_batch_fetched_for_firs")
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error test-fetching invoice batch: {e}")
            raise HTTPException(status_code=502, detail="Failed to test-fetch invoice batch")
    
    def _create_v1_response(self, data: Dict[str, Any], action: str, status_code: int = 200) -> V1ResponseModel:
        """Create standardized v1 response format"""
        return build_v1_response(data, action)

    async def _route_with_si_retry(self, operation: str, payload: Dict[str, Any], *, retry: bool = True) -> Dict[str, Any]:
        """Route to SI services, re-initializing registrations if none are found."""
        try:
            return await self.message_router.route_message(
                service_role=ServiceRole.SYSTEM_INTEGRATOR,
                operation=operation,
                payload=payload,
            )
        except RuntimeError as exc:
            message = str(exc)
            retryable = (
                "No service responses received" in message
                or "No routing rules configured" in message
                or "No target endpoints" in message
            )
            if retry and retryable:
                try:
                    from si_services import initialize_si_services

                    await initialize_si_services(self.message_router)
                except Exception as reinit_err:
                    logger.warning("Failed to reinitialize SI services: %s", reinit_err)
                else:
                    logger.info("Reinitialized SI services after missing endpoint for %s", operation)
                    return await self._route_with_si_retry(operation, payload, retry=False)
        except Exception:
            raise
        raise RuntimeError(f"Unable to route operation {operation}; SI services unavailable.")


def create_erp_router(role_detector: HTTPRoleDetector,
                     permission_guard: APIPermissionGuard,
                     message_router: MessageRouter,
                     onboarding_service: Optional[SIOnboardingService] = None) -> APIRouter:
    """Factory function to create ERP Router"""
    erp_endpoints = ERPEndpointsV1(
        role_detector,
        permission_guard,
        message_router,
        onboarding_service=onboarding_service,
    )
    return erp_endpoints.router
